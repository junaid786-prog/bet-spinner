function Spinwheel(t) {
    var e = {
        el: "#spinwheel",
        canvas_size: 700,
        fonts: [""],
        messageContainer: "#spinwheel-messages",
        showMessages: !0,
        graphicPath: "../double-spin_files",
        graphics: {
            bg: { file: "o_wheelBackground.png" },
            segments: [{ file: "o_wheelSegments.png" }],
            spinBtn: { file: "o_wheelSpinButton.png" },
            lightOff: { file: "o_wheelLightOff.png" },
            lightOn: { file: "o_wheelLightOn.png" },
            arrow: { file: "o_arrow.png" }
        },
        components: {
            bg: { rotate: 0, scale: .9, rotateBy: 0 },
            spinBtn: { rotate: 0, scale: .2, clickableScale: !1, text: "SPIN", font: "Arial", fontSize: 35, fontWeight: 400, fontColor: "white", fontShadowColor: "white", fontShadowBlur: 0, fontStrokeColor: "rgba(0,0,0,0.4)", fontStrokeWeight: 5, fontOffsetX: 0, fontOffsetY: 0 }, segments: [{ rotate: 0, rotateBy: 10, scale: .73, textRadius: .78, font: "Arial", fontSize: 24, fontWeight: 400, fontColor: "black", fontShadowColor: "", fontShadowBlur: 0, fontStrokeColor: "", fontStrokeWeight: 0, textPosition: "short", lineGap: -5 }], light: { count: 40, radius: .76, scale: .05, states: { start: { type: "cycle", fadeSpread: 10, delay: 100 }, spinning: { type: "cycle", fadeSpread: 10, delay: 25 }, end: { type: "flash", delay: 150, endAfter: 3e3 } } }, arrow: { rotate: 0, scale: .25, x: 0, y: .78 }
        }, segmentLabels: [[{ text: ["50%", "MATCH"], isWin: !0 }, { text: ["TRY", "AGAIN"] }, { text: ["10", "CHANCES"], isWin: !0 }, { text: ["MYSTERY", "PRIZE"], isWin: !0, fontColor: "white" }, { text: ["10", "CHANCES"], isWin: !0 }, { text: ["TRY", "AGAIN"] }, { text: ["50%", "MATCH"], isWin: !0 }, { text: ["10", "CHANCES"], isWin: !0 }]], spinTime: 3e3, stages: ["0,1", "0,2", "0,3"], winAngle: 0, drawArrow: !0, shroudColour: "rgba(0,0,0,0)", rotateSegmentsOnIdle: !0, hideSpinTextOnSpin: !0, init: function () { console.log(this) }, onSpin: function () { document.getElementById("wheel").play(), console.log("spinning wheel") }, onLand: function () { }, messageShown: function () { }, messageHidden: function () { }
    }; if ("components" in t) { for (var n in t.components) Array.isArray(t.components[n]) ? t.components[n] = Object.assign([], e.components[n], t.components[n]) : t.components[n] = Object.assign({}, e.components[n], t.components[n]); t.components = Object.assign({}, e.components, t.components) } var o, a, r, i, s, l, g = { o: t = Object.assign({}, e, t) }; s = "string" == typeof g.o.el ? document.querySelector(g.o.el) : g.o.el, l = "string" == typeof g.o.messageContainer ? document.querySelector(g.o.messageContainer) : g.o.messageContainer; var c = g.o.canvas_size, f = g.o.canvas_size, h = !1; canvas = document.createElement("canvas"), canvas.setAttribute("width", c), canvas.setAttribute("height", f), s.style.width = c + "px", r = {}, i = canvas.cloneNode(), r.bg = { canvas: i, ctx: i.getContext("2d") }; for (var d = g.o.components.segments, m = 0; m < d.length; m++)i = canvas.cloneNode(), r["seg_" + m] = { canvas: i, ctx: i.getContext("2d") }; for (var n in i = canvas.cloneNode(), r.fg = { canvas: i, ctx: i.getContext("2d") }, r) r[n].canvas.setAttribute("data-layer", n), s.appendChild(r[n].canvas); g.getItemByString = function (t, e) { void 0 === e && (e = {}); for (var n = t.split("_"), o = 0; o < n.length; o++)e = e[n[o]]; return e }, g.stringToIntArray = function (t, e) { void 0 === e && (e = ","); for (var n = t.split(e), o = 0; o < n.length; o++)n[o] = parseInt(n[o]); return n }, g.doInitialDraw = function () { g.drawSegments(); var t = document.createElement("div"); t.classList.add("btn-spin"), t.classList.add("spin-button"); var e = g.o.components.spinBtn; if ("clickableScale" in e && !1 !== e.clickableScale) var n = e.clickableScale; else n = e.scale; var a = g.o.graphics.spinBtn.img, r = c * n, i = a.height * (r / a.width); r = r / c * 100, i = i / f * 100, t.style.width = r + "%", t.style.height = i + "%", s.appendChild(t); for (var l = document.querySelectorAll(".btn-spin"), h = 0; h < l.length; h++)l[h].addEventListener("click", g.spin); for (l = document.querySelectorAll(".btn-hide-message"), h = 0; h < l.length; h++)l[h].addEventListener("click", g.hideMessage); o = window.requestAnimationFrame((function (t) { y(t, !0) })), g.o.init() }, g.initWheel = function () { g.o.state = "start", g.o.lightState = "start", g.o.currentStage = 0, g.o.segmentAngle = 360 / g.o.segmentLabels[0].length; for (var t = g.stringToIntArray(g.o.stages[g.o.currentStage]), e = g.o.components.segments, n = 0; n < e.length; n++)e[n].revolutions = 0, e[n].showShroud = !0; e[t[0]].showShroud = !1 }, g.initSegments = function (t) { var e = g.o.components.segments[t], n = g.o.segmentLabels[t]; e.startAngle = e.rotate; for (var o = 0; o < n.length; o++)n[o].rotate = o * (360 / n.length) - 90 + e.rotate }, g.initLights = function () { var t = g.o.components.light; t.nextIndex = 0, t.elapsed = 0, t.warmup = !0, g.o.lightsArray = []; for (var e = 0; e < t.count; e++)g.o.lightsArray.push({ onOpacity: 0, fadeDir: 1 }); g.o.components.light.startTime = 0 }, g.setLightState = function (t, e) { g.o.lightState = e, g.o.components.light.startTime = t }, g.spin = function () { "start" == g.o.state && (g.o.state = "start-spin", document.getElementById("wheel").play(), g.drawSegments(), g.hideMessage(), g.o.onSpin(g.o.currentStage)) }, g.hideMessage = function () { if (g.o.showMessages) { for (var t = l.querySelectorAll(".message"), e = 0; e < t.length; e++)t[e].classList.remove("active"); l.classList.remove("active"), g.o.messageHidden(g.o.currentStage > 0 ? g.o.currentStage - 1 : 0) } }, g.transformImage = function (t) { var e = g.o.components[t]; "rotateBy" in e && (e.rotate += e.rotateBy, e.rotate = e.rotate % 360) }, g.drawImage = function (t, e, n) { void 0 === n && (n = !0), void 0 === e && (e = r.bg.ctx), e.save(); var o = g.getItemByString(t, g.o.components), a = c / 2, i = f / 2, s = "x" in o ? c * o.x : 0, l = "y" in o ? c * o.y : 0; n && e.translate(a + s / 2, i - l / 2), n && e.rotate(o.rotate * Math.PI / 180), img = g.getItemByString(t, g.o.graphics).img; var h = c * o.scale, d = h / img.width, m = img.height * d; e.drawImage(img, -h / 2, -m / 2, h, m), e.restore(); var p = !0; if (g.o.hideSpinTextOnSpin && "spinBtn" == t && "start" != g.o.state && (p = !1), "text" in o && p) { if (e.save(), e.translate(a, i), e.textBaseline = "middle", e.textAlign = "center", Array.isArray(o.text)) for (var u = 0; u < o.text.length; u++) { var v = o.fontSize * u; g.drawText(o, o.text[u], 0, v, e) } else g.drawText(o, o.text, 0, 0, e); e.restore() } }, g.moveWheel = function (t, e) { void 0 === t && (t = 0); var n = g.o.segmentLabels, o = g.o.components.segments[t]; if (void 0 === e && (e = "rotateBy" in o ? o.rotateBy : 0), e > 0) { var a = (o.rotate + e) % 360; o.rotate = a, a < o.rotate && o.revolutions++; for (var r = 0; r < n.length; r++)n[r].rotate = (n[r].rotate + e) % 360 } }, g.drawSegments = function () { for (var t = g.o.components.segments, e = 0; e < t.length; e++) { var n = t[e], o = g.o.segmentLabels[e], a = r["seg_" + e].ctx; a.clearRect(0, 0, c, f), g.initSegments(e), r["seg_" + e].canvas.style.transform = "rotate(0deg)", g.drawImage("segments_" + e, a); var i = c / 2, s = f / 2, l = c * n.scale * n.textRadius / 2; a.textBaseline = "middle", a.textAlign = "center"; for (var h = n.textPosition, d = n.lineGap, m = 0; m < o.length; m++) { var p = o[m]; if (a.save(), a.translate(i, s), "short" == h && (p.rotate += 90), a.rotate(p.rotate * Math.PI / 180), "long" == h ? a.translate(l, 0) : "short" == h && a.translate(0, -l), _style = Object.assign({}, n, p), "text" in p) for (var u = (p.text.length - 1) * (n.fontSize / 2) * -1 - d / 2, v = 0; v < p.text.length; v++) { var S = u + (n.fontSize + d) * v; g.drawText(_style, p.text[v], 0, S, a) } else "image" in p && g.drawImage(p.image, a, !1); a.restore() } if (n.showShroud) { a.save(), a.translate(i, s); var w = c * n.scale; a.arc(0, 0, w / 2, 0, 2 * Math.PI, !1), a.fillStyle = g.o.shroudColour, a.fill(), a.restore() } } }, g.drawText = function (t, e, n, o, a) { if (void 0 === a && (a = r.bg.ctx), "font" in t && h || (t.font = "sans-serif"), a.font = t.fontWeight + " " + t.fontSize + "px " + t.font, a.miterLimit = 2, "fontOffsetX" in t && (n += t.fontOffsetX), "fontOffsetY" in t && (o += t.fontOffsetY), "fontShadowBlur" in t && t.fontShadowBlur > 0 && (a.save(), "fontShadowColor" in t && (a.shadowColor = t.fontShadowColor, a.strokeStyle = t.fontShadowColor), "fontStrokeWeight" in t && t.fontStrokeWeight > 0 && (a.lineWidth = t.fontStrokeWeight - 1), "fontShadowBlur" in t && (a.shadowBlur = t.fontShadowBlur), a.strokeText(e, n, o), a.restore()), "fontStrokeWeight" in t && t.fontStrokeWeight > 0 && (a.save(), "fontStrokeWeight" in t && (a.lineWidth = t.fontStrokeWeight), "fontStrokeColor" in t && (a.strokeStyle = t.fontStrokeColor), a.strokeText(e, n, o), a.restore()), a.save(), Array.isArray(t.fontColor)) { for (var i = a.createLinearGradient(0, o - 5, 0, o + 5), s = 0; s < t.fontColor.length; s++)i.addColorStop(s, t.fontColor[s]); a.fillStyle = i } else a.fillStyle = t.fontColor; a.fillText(e, n, o), a.restore() }, g.drawLights = function () { for (var t = g.o.components.light, e = g.o.lightsArray, n = r.fg.ctx, o = 0; o < e.length; o++) { n.save(); var a = g.o.graphics.lightOff.img, i = c * t.scale, s = i / a.width, l = a.height * s, h = c / 2, d = f / 2; n.translate(h, d), n.rotate(360 / t.count * o * Math.PI / 180), n.drawImage(a, -i / 2 + c / 2 * t.radius, -l / 2, i, l); a = g.o.graphics.lightOn.img; n.globalAlpha = e[o].onOpacity, n.drawImage(a, -i / 2 + c / 2 * t.radius, -l / 2, i, l), n.restore() } }, g.cycleLights = function (t) { var e = g.o.components.light, n = g.o.lightsArray, o = g.o.lightState, a = e.states[o]; if (t -= e.startTime, "flash" == a.type) for (var r = Math.ceil(t % a.delay), i = r / a.delay, s = 0; s < n.length; s++) { if (r < e.elapsed) { if ("endAfter" in a && t > a.endAfter && 0 == n[s].fadeDir) return g.initLights(), void g.setLightState(t, "start"); n[s].fadeDir = 0 == n[s].fadeDir ? 1 : 0 } 1 == n[s].fadeDir ? n[s].onOpacity = i : n[s].onOpacity = 1 - i } else if ("cycle" == a.type) { var l = 1 / a.fadeSpread; if (e.warmup) for (s = 0; s < a.fadeSpread; s++)s <= e.nextIndex && (n[s].onOpacity = s * l), e.nextIndex == a.fadeSpread && (e.warmup = !1); else for (s = 0; s < a.fadeSpread; s++) { var c = e.nextIndex - s; c < 0 && (c = n.length + c), n[c].onOpacity = 1 - l * s } t % a.delay < e.elapsed && (e.nextIndex + 1 < n.length ? e.nextIndex++ : e.nextIndex = 0) } e.elapsed = t % a.delay }, g.prepareNextSpin = function () { for (var t = g.o.components.segments, e = 0; e < t.length; e++)t[e].revolutions = 0; g.o.currentStage + 1 < g.o.stages.length ? (g.o.state = "start", g.o.currentStage++) : (g.o.state = "stopped", document.getElementById("funfare").play(), startTimer()) }; var p, u = []; for (var n in g.o.graphics) { var v = g.o.graphics[n], S = []; if (Array.isArray(v)) for (m = 0; m < v.length; m++) { var w = v[m]; S.push({ src: g.o.graphicPath + w.file, key: n + "_" + m }) } else S.push({ src: g.o.graphicPath + v.file, key: n }); for (m = 0; m < S.length; m++)u.push(new Promise((function (t, e) { !function (n) { var o = new Image; o.src = n.src, o.onerror = function () { e(o) }, o.onload = function () { t({ img: o, key: n.key }) } }(S[m]) }))) } function y(t, e) { (void 0 === a || e) && (a = t); var n = t - a; r.fg.ctx.clearRect(0, 0, c, f), r.bg.ctx.clearRect(0, 0, c, f), g.drawImage("spinBtn", r.fg.ctx), g.drawImage("bg", r.bg.ctx), g.o.components.light.count > 0 && (g.cycleLights(n), g.drawLights()), g.o.drawArrow && g.drawImage("arrow", r.fg.ctx), g.transformImage("bg"); var i = g.stringToIntArray(g.o.stages[g.o.currentStage]), s = g.o.components.segments[i[0]]; if (r["seg_" + i[0]].canvas.style.transform = "rotate(" + (s.rotate - s.startAngle) + "deg)", "start-spin" == g.o.state && (g.o.spinStart = t, "end" == g.o.lightState && g.initLights(), g.o.state = "spinning", g.setLightState(n, "spinning")), "spinning" == g.o.state && t - g.o.spinStart > g.o.spinTime) { var h = (360 * s.revolutions + s.rotate) % 360, d = 360 - g.o.segmentAngle * i[1] - h + g.o.winAngle; (d %= 360) < 0 && (d += 360), d > 45 && d < 90 && (g.o.state = "stopping", s._rotate = s.rotate, s._timeStart = t, s._changeBy = Math.abs(d)) } if ("stopping" == g.o.state) { var m = t - s._timeStart; if (m / 1e3 <= 1) { var p = easeOutBack(m / 1e3, s._rotate, s._changeBy, 1) - s.rotate; s.rotate += p; for (var u = g.o.segmentLabels, v = 0; v < u.length; v++)u[v].rotate += p } else { g.o.onLand(g.o.currentStage); var S = g.o.segmentLabels[i[0]][i[1]]; "isWin" in S && 1 == S.isWin ? g.setLightState(n, "end") : g.setLightState(n, "start"), g.o.state = "stopped", window.setTimeout((function () { g.o.showMessages && (l.querySelectorAll(".message")[g.o.currentStage].classList.add("active"), l.classList.add("active"), g.o.messageShown(g.o.currentStage)); if (g.o.currentStage + 1 < g.o.stages.length) { var t = g.stringToIntArray(g.o.stages[g.o.currentStage + 1]); g.o.components.segments[t[0]].showShroud = !1, g.drawSegments() } g.prepareNextSpin() }), 1e3) } } else "spinning" == g.o.state && g.moveWheel(i[0]); "start" == g.o.state && g.o.rotateSegmentsOnIdle && g.moveWheel(i[0], .3), o = window.requestAnimationFrame(y) } return Promise.all(u).then((function (t) { for (var e = 0; e < t.length; e++) { var n = t[e]; g.getItemByString(n.key, g.o.graphics).img = n.img } g.initWheel(), g.initLights(), o && window.cancelAnimationFrame(o), "fonts" in g.o && g.o.fonts.length > 0 ? WebFont.load({ custom: { families: g.o.fonts }, active: function () { h = !0, g.doInitialDraw() }, fontinactive: function (t) { throw g.doInitialDraw(), new Error("FONT " + t + " COULD NOT BE LOADED") } }) : g.doInitialDraw() })).catch((function (t) { console.log(t) })), document.addEventListener("visibilitychange", (function () { if (document.hidden) p = (new Date).getTime(); else { var t = (new Date).getTime() - p; a += t; for (var e = g.o.components.segments, n = 0; n < e.length; n++)e[n]._timeStart += t } }), !1), g
} function easeOutBack(t, e, n, o) { return s = 4, n * ((t = t / o - 1) * t * ((s + 1) * t + s) + 1) + e } function easeInOutCubic(t, e, n, o) { return (t /= o / 2) < 1 ? n / 2 * t * t * t + e : n / 2 * ((t -= 2) * t * t + 2) + e } function easeLinear(t, e, n, o) { return n * t / o + e } function randomFloat(t, e) { return Math.random() * (e - t) + t } function randomInt(t, e) { return Math.floor(Math.random() * (e - t + 1) + t) } function isBlank(t) { return !t || /^\s*$/.test(t) } window.NodeList && !NodeList.prototype.forEach && (NodeList.prototype.forEach = function (t, e) { e = e || window; for (var n = 0; n < this.length; n++)t.call(e, this[n], n, this) }), "function" != typeof Object.assign && Object.defineProperty(Object, "assign", { value: function (t, e) { "use strict"; if (null == t) throw new TypeError("Cannot convert undefined or null to object"); for (var n = Object(t), o = 1; o < arguments.length; o++) { var a = arguments[o]; if (null != a) for (var r in a) Object.prototype.hasOwnProperty.call(a, r) && (n[r] = a[r]) } return n }, writable: !0, configurable: !0 });